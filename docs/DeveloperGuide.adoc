= AlphaNUS - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-F10-3/main/blob/master

By: `AY1920S1-CS2113T-F10-3` Since: `Aug 2019` Licence: `NUS`
Team members: http://github.com/leowyh[Leow Yong Heng] |
http://github.com/lijiayu980606[Li Jiayu] |
http://github.com/E0373902[Shriya Saxena]
| http://github.com/karansarat[Karan Sarat]

== Introduction

=== About AlphaNUS

NUS treasurers often come face to face with piles of payment forms filled with payments for claims and also need to
keep track of their statuses. Having to manage and allocate club funds to multiple projects, treasurers
may find it a chore to keep up to date with their finances.

*AlphaNUS* is a financial management assistant for treasurers to keep track of payment forms made by payees as well as manage the club's funds for projects.

This developer guide includes detailed documentation on the designs and implementations of the project and how developers can make changes it.

== Setting up

=== Prerequisites

. *JDK `11`* or above
. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

// tag::Design[]
== Design
.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above displays the n-tier architecture design of the AlphaNUS. Given below is a quick overview of each component.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Command,*`Command`*>>: The command executor and parser.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

The UI solely consists of a `Ui` object that is initiated at the start of the program.

The `UI` component,

* Executes user commands using the `Command` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Command]]
=== Command component

.Structure of the Command Component
image::CommandClassDiagram.png[]

The `Command` component consists of:

* `Parser` to make sense of user input.
* `Instruction` to determine which process to execute.
* `Process` to process the execution of the command.

[[Design-Model]]
=== Model component
[[fig-ModelClassDiagram]]
.Structure of the Model Component
image::ModelClassDiagram.png[]

.  Both `Project Manager` and `Payment Manager` takes in user command from `Command`.
.  The `Project Manager` class manages a HashMap of `Project` objects.
.  Each `Project` object contains a `Budget` and a HashMap of `Payee` objects.
.  Each `Payee` object contains an ArrayList of `Payments` objects.
.  The result of the command execution is encapsulated as a `Project` object by `PaymentManager` and passed back to `Command`.

[[Design-Storage]]
=== Storage component
[[fig-StorageClassDiagram]]
.Structure of the Storage Component
image::StorageClassDiagram.png[]

.  `Storage` is used by the `Command` component to read and write data from local storage.
.  The data that is stored is saved as json files and serialized using Gson.


// end::Design[]
// tag::Project[]
== Implementation
This section describes some noteworthy details on how certain features are implemented.


=== Project Feature
==== Project Class
The `Project` Class object stores the project's budget details along with a HashMap of `Payee` objects consisting of payees have made payments for a project. A `Project` object can be constructed with or without a budget assigned to it depending on user input.
The following are the class members storing the project's details.

** Total budget for the Project : `budget`
** Spending made by Payees : `spending`
** Remaining budget : `remaining`
** Name of the project : `projectname`

==== Project Feature Commands
The `project` feature is managed by the `ProjectManager` class, which is called by the
`Process` class in the `Command` component.

This feature supports the following commands:

* `add project pr/PROJECT_NAME am/AMOUNT` -- Adds a new project to the record.
* `delete project pr/PROJECT_NAME` -- Deletes a project from the record.
* `goto project PROJECT_INDEX_IN_LIST` -- Go to a project in the record.
* `list projects` -- Lists all projects in the record.


==== ProjectManager
The `ProjectManager` class is subclassed in the project package, which contains the `Project` and `Fund` classes. It serves to process the input from the `Command` package and implement the project feature commands (Section 4.1.2) along with fund feature commands(Section TBC). The `ProjectManager` class implements the following methods:

* ProjectManager#addProject
* ProjectManager#deleteProject
* ProjectManager#gotoProject
* ProjectManager#assignBudget
* ProjectManager#getCurrentProjectManagerMap
* ProjectManager#loadBackup
* ProjectManager#updateDict
* ProjectManager#findPayee
* ProjectManager#findPayee

A detailed explanation of the use case for the `add project` command is given below to demonstrate how each component interacts with each other.

1. User executes the command `add project pr/RAG` in the CLI. This input is passed from the `Ui` to `Command` where the input will be parsed to determine the command to execute.

2. The `Command` component will process the `add project` command and execute it in the `Model` component, calling `ProjectManager` to add a new `Project` object with the user defined `PROJECT_NAME` to its HashMap of `Project` objects.

3. `ProjectManager` then returns a value of the newly created `Project` object to `Command` which is passed to `Ui` for printing the project details to the user.

Below is a sequence diagram to provide a visual representation of the `add project` command.

[[fig-AddProjectSeqDiagram]]
.Sequence Diagram of the add project command
image::AddProjectSeqDiagram.png[]

The `delete project` command is implemented in the same manner to the `add project` command. Both return the `Project` object that was deleted or added to be passed to `Ui` for printing its details to the user. The `delete project` command only differs from the `add project` command when it deletes the `Project` object from the HashMap of `Project` objects, in contrast to adding a `Project` object to the HashMap.

// end::Project[]

=== Fund Feature
==== Fund Class
==== Fund Feature Commands

//tag::payee
=== Payee Feature
==== Payee Class
The `Payee` Class object holds all information regarding the identity of the payee, as well as an ArrayList `payments` of `Payment` objects.
When a new `Payee` object is created, it is stored in the respective HashMap `managerMap` for the specific project the payee is being paid for. +
The following are the class members storing the payee's identity information.

** Project Name : `project`
** Payee Name : `name`
** Email Address : `email`
** Matriculation Number : `matricNum`
** Phone Number : `phoneNum`

==== Payments Class
The `Payments` Class object stores the details of the payment being made. A `Payments` object once constructed will be added to the ArrayList `payments` member of the specified payee the payment is being made to.
The following are the class members storing the payment's details.

** Project : `project`
** Payee Name : `name`
** Description of Payment : `item`
** Amount being paid : `cost`
** Invoice Number : `inv`
** Due date for payment : `deadline`

Note that the due date is automatically set to 30 days after the creation of the `Payments` object.

==== Field and Status Enums
The feature is also supported by 2 enum objects, `Field`; +

** PAYEE
** EMAIL
** MATRIC
** PHONE
** ITEM
** COST
** INVOICE
** DEADLINE
** STATUS

and `Status`: +

** PENDING
** APPROVED
** OVERDUE

==== Payee Feature Commands
The payee feature supports the following commands:

* `add payee p/name e/email m/matricNum ph/phoneNum` -- Adds a new payee to the record.
* `add payment p/name i/item c/cost v/inv` -- Adds a new payee to the record.
* `delete payee p/name` -- Deletes a payee from the record.
* `delete payment p/name v/inv` -- Deletes a payment from the record.
* `edit p/name f/field r/replacement` -- Edits data for an existing payee in the record.
* `find payee p/name` -- Finds details of a specified payee in the record, across all projects.
* `find payment p/name i/item` -- Finds details of a specified payment in the record, across all projects.
* `list payments` -- Lists all payments for the current project in the record.
* `list payments pr/name` -- Lists all payments for specified project in the record.
* `list payments p/name` -- Lists all payments for specified payee in the record.

==== PaymentManager
The `PaymentManager` is an abstract class that is subclassed in the payments package, which contains the `Payee` and `Payments` classes. It serves to process the input from the `Command` package and implement the payee feature commands (Section 4.3.4). The `PaymentManager` class implements the following methods:

* PaymentManager#addPayee
* PaymentManager#addPayments
* PaymentManager#deletePayee
* PaymentManager#deletePayments
* PaymentManager#editPayee
* PaymentManager#findPayee
* PaymentManager#checkStatus

[[fig-AddPayeeSeqDiagram]]
.Sequence Diagram of the add payee command
image::AddPayeeSeqDiagram.png[]

A detailed explanation of the use case for the add payee command is given below to demonstrate how each component interacts with each other. +
1. User executes the command `add payee p/name e/email m/matricNum ph/phoneNum` in the CLI. This input is passed from the Ui to Parser where the input will be parsed to determine the command to execute. It then invokes Process, which splits the user input and breaks down the user's intended answer into information our classes can interact with. +
2. The PaymentManager is invoked, and in this case, the addPayee method is called. The method checks which project is currently selected and constructs a new Payee object. The Payee object is pushed into the current project's managerMap, a HashMap of all the project's payees. +
3. Assuming a valid input was passed from the user, a confirmation message showing the summary of the details of the newly created Payee would be printed. Else, an error will prompt the user to try again and provide the correct template for the command they attempted. In Process, most of the Exception handling is done to catch all possible user error cases. +

The Payment Manager handles most other commands the same way, given that all payee information is stored within a single project LinkedHashMap, and all payment information is stored in an ArrayList in each Payee. The only method in Payment Manger that is different is the helper function 

=== History Feature
The `history` feature is implemented to keep track of the list of all input commands entered by the user. It is facilitated by the `Storage` class which is called by the `Process` class in the `command` component.

This feature supports the following commands:

* `history` - lists all the input commands(with the date and time beside) entered by the user.
* `view history h/DATE_1 to DATE_2` - lists the input commands entered by the user during a certain period.

The use case for the `history` command is given below to show how each component interacts with each other.

1. The user executes the `history` command in the CLI. The input is passed from `Ui` to `command` to determine the command to execute.

2. The `Command` component will process the `history` command and load the json file consisting the input commands from the `Storage` class into an arraylist.

3. This arraylist is passed to `Ui` for printing the list of input commands, along with the date and time it was entered, to the user.

Below is the sequence diagram showing the interactions between the different components used to implement the `history` command.

image::Slide1.PNG[]

==== Design Considerations
===== Aspect: How `view history h/DATE to DATE` is implemented
* Alternative 1: The application loops through the arraylist of all the input commands loaded from the json file in storage. In the for loop, it is checked if the date beside the command is within the date range provided in the input. If yes, then it is added to a new arraylist, which is printed once the application has gone through the for loop.

=== Undo Redo Feature
The Undo Redo Feature is implemented for the users to quickly redo an action or reverse an action they entered by mistake. It is facilitated by the `BeforeAfterCommand` class which is called by the `Process` class in the `command` component.

This feature supports the following commands:
`undo`- undoes the previous command.(only the ones mentioned in the User Guide)
`redo`- redoes an undone command.

The use case for the `undo` command is given below to show how each component interacts with each other.

1. The user executes the `undo` command in the CLI. The input is passed from `Ui` to `command` to determine the command to execute.

2. The `Command` component will process the `undo` command and read from the json file consisting the previous state of the projectmap stored in `Storage`.

3. This state is passed to `Parser` and is written to the storage when the program is exited with the `bye` command.

Below is the sequence diagram showing the interactions between the different components used to implement a command that can be undone.

image::command.PNG[]

Below is the sequence diagram showing the interactions between the different components used to implement the `undo` command.

image::undo seq diagram.PNG[]

//tag::fund[]
=== Fund feature
The Fund Feature is implemented to provide convenience to our target audience
and reduce the manual calculations required to manage the finance of an organisation. +
This feature extends the AlphaNUS with an overall fund.  The fund is stored locally in a local folder
and is loaded every time the user starts the application. +
Currently, it implements the following implementations:

* `fund#setFund` -- Set a new fund to all projects.
* `fund#takeFund` -- Take value from funds and assign it to a specific project as the project's budget.
* `fund#addFund` -- Add more fund to the original fund
* `fund#retrieveFund` -- Retrieve the unused budget and add it back into fund when a project is deleted.

This feature allows the following commands:

* *Set Fund:*            `set fund am/AMOUNT`
* *Add Fund:*            `add fund add/AMOUNT`
* *Assign budget:*         `assign budget pr/PROJECT_NAME am/AMOUNT`
* *Change Fund:*        `change fund new/AMOUNT`
* *Show Fund:*           `show fund`

Given below is an example usage scenario and how the fund mechanism behaves at each step.

* Step 1: The user run the application for the first time. He cannot call any other fund commands as the fund is not set yet.
He thus input `set fund am/2000` and set the overall command as 2000 dollars.
* Step 2: The user can now perform `add fund add/AMOUNT` and `change fund new/AMOUNT` to change the fund.
He can also call `show fund` to see the current fund status. However he cannot call `assign fund pr/PROJECT am/AMOUNT` as
there is no projects yet.
* Step 3: The user adds a project by calling `add project` command. He can assign a budget from the fund
when creating the project, or assign later by calling the `assign fund` function.
* Step 4: The user exits the application. The fund object is stored in a json file under localdata folder.
* Step 5: The user reopen the application. The fund object is loaded from the json file.
* Step 6: The user can now call all commands related to funds.

==== Design Considerations

===== Aspect: How fund feature executes

* **Alternative 1 (current choice):** automatically save to and load from local folder as string. User can directly call commands to change it.
** Pros: Easy to implement.
** Cons: The data is not safe. unauthorized user can change it from the json file or call relative commands.
* **Alternative 2(Proposed and preferred):** automatically save to and load from local folder as encoded strings. User needs to input a security key to call commands to changeit.
** Pros: Protect important data such as total fund to be changed by unauthorized user.
** Cons: The steps would become more tedious and les convenient.

===== Aspect: Data structure to support the fund commands

* **Alternative 1 (current choice):** Use a Fund object.
** Pros: Can show different attributes such as fund.remaining and fund.taken, which makes the feature more useful
and easy to use.
** Cons: Relatively more complex as compare to Alternative 2
* **Alternative 2:** Use a global double variable.
** Pros: Simple and straightforward.
** Cons: Less useful as it provides less functions and implementations as in Alternative 1
// end::fund[]

//tag::budget[]
=== Budget feature
The Budget Feature is implemented to provide convenience to our target audience
and reduce the manual calculations required to manage the finance of an organisation. +
This feature  extends the project features with a budget for each project object. The budget for a project is automatically
saved in a json file in localdata folder.

This feature allows the following commands:

* *Assign budget:*         `assign budget pr/PROJECT_NAME am/AMOUNT`
* *Reduce budget:*         `reduce budget pr/PROJECT_NAME am/AMOUNT`
* *Show Fund:*           `show fund`

Given below is an example usage scenario and how the fund mechanism behaves at each step.

* Step 1: The user run the application for the first time. He cannot call `assign fund pr/PROJECT am/AMOUNT` as
 no project is added and fund is not set yet. He cannot call `reduce fund pr/PROJECT am/AMOUNT` as well.
* Step 2: The user sets a fund of 2000 dollars and adds a project named "Rag". He can assign a budget from the fund
when creating the project, or assign later by calling the `assign fund` function.
* Step 3: He can add new payee and payments which take their costs from the budget until the remaining budget is not
enough to cover the cost of the new-added payments. He can reduce budget from the project the the reduced budget will be added back to fund. He can reduce budget from the project the the reduced budget will be added back to fund.
* Step 4: The user exit the application. The budget is saved as an attribute of the relative project in a json file.
* Step 5: The user reopen the application. The budget is loaded together with the project it belongs to.

==== Design Considerations

===== Aspect: How fund feature executes

* **Alternative 1 (current choice):** automatically save to and load from local folder as string. User can directly call commands to change it.
** Pros: Easy to implement.
** Cons: The data is not safe. unauthorized user can change it from the json file or call relative commands.
* **Alternative 2(Proposed and preferred):** automatically save to and load from local folder as encoded strings. User needs to input a security key to call commands to change it.
** Pros: Protect important data such as total fund to be changed by unauthorized user.
** Cons: The steps would become more tedious and les convenient.

// end::budget[]

//tag::task[]
=== Task feature
The Task Feature is implemented to provide convenience to our target audience
to manage other tasks with or without a deadline. +
This feature extends the AlphaNUS with a Arraylist of task named tasklist.  The fund is stored locally in a local folder
and is loaded every time the user starts the application. +
This feature allows the following commands:

* *Add Todo:*            `add todo d/DESCRIPTION`
* *Add Deadline:*        `add deadline d/DESCRIPTION by/DATE.`
* *Done Task:*           `done id/ID`
* *Delete Task:*         `delete task id/ID`
* *Find Task:*          `find task key/KEY_WORD`
* *List Tasks:*          `list tasks`
* *Snooze Deadline:*     `snooze id/ID`
* *Postpone Deadline:*   `postpone id/ID n/DAYS`
* *Reschedule Deadline:* `reschedule id/ID d/DATE`
* *View Schedule:*       `view schedule d/DATE`

Given below is an example usage scenario and how the fund mechanism behaves at each step.

* Step 1: The user run the application for the first time. The first step he can take is adding in todo or deadline tasks based on his needs
* Step 2: The user can now perform other commands such as list/find/view schedule on the tasklist, or done/delete/reschedule on individual tasks.
* Step 4: The user exits the application. The tasklist object is stored in a json file under localdata folder.
* Step 5: The user reopen the application. The tasklist object is loaded from the json file.
* Step 6: The user can now call all commands related to tasks.
//end::task[]

//tag::reminder[]
=== Reminder feature
The reminder feature is implemented to provide convenience to our target audience
by allowing the to keep track on the submission deadlines of payment forms easily. +
This feature  extends the project and payment features and sort payments across all projects based on their deadlines.

This feature allows the following command:
* *Reminder:*            `reminder`

Given below is an example usage scenario and how the fund mechanism behaves at each step.

* Step 1: The user has one or more projects added.
* Step 2: The user has added in one or more payments, each has an auto-generated deadline based on the date it was added.
* Step 3: The user can set the status of some payments as `APPROVED`.
* Step 4: He can then call the `reminder` command, which returns a list of all pending and overdue payments.
The payments are sorted according to their priority(i.e. sorted based on the deadline)

==== Design Considerations

===== Aspect: How fund feature executes

* **Alternative 1 (current choice):** Takes payments from all projects and store it into a temporary arraylist.
Then the arraylist is sorted based on the payments' dates.
** Pros: Provides helpful results which helps users to know the priority of payment forms easier
** Cons: Long execution time as compared to the 2nd alternative when there are a great number of payment forms.
* **Alternative 2(Proposed and preferred):** Only process and sort the payments in current project.
** Pros: Easier to implement and faster
** Cons: Less Meaningful.
//end::reminder[]

== Documentation

=== Introduction

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[appendix]
== Product Scope

*Target user profile*:

* NUS treasurers who need to track a large number of payment forms
* manages the finances of multiple projects at once
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: Manage payments faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |NUS Treasurer |add the budget for an event |spend within my budget

|`* * *` |NUS Treasurer |add my deadlines |keep track of the payments to be submitted

|`* * *` |NUS Treasurer |add payees for payments|keep track of the payments made by each payee

|`* * *` |NUS Treasurer |delete payees who made payments|remove payees whom I do not need to track

|`* * *` |NUS Treasurer |add payments made by payees|keep track of the payments made by each payee

|`* * *` |NUS Treasurer |delete payments made by payees|remove payments which I do not need to track

|`* *` |NUS Treasurer |import files to update my payments made by a payee |do not have to manually input it myself

|`* *` |NUS Treasurer |export my payments for a project into a statement of accounts |can submit it to my supervisors

|`* *` |NUS Treasurer |set priorities for each deadline |decide which task to finish first

|`* *` |NUS Treasurer |keep track of projects that I am in-charge of |manage the payments for each project

|`* *` |NUS Treasurer |view the amount of money remaining from my budget |budget my spending better

|`* *` |NUS Treasurer |edit my forms easily |correct any mistakes i make

|`* *` |NUS Treasurer |delete my forms easily |correct any mistakes i make

|`* *` |NUS Treasurer |find my forms easily |locate details of an event without going through the whole list

|`* *` |NUS Treasurer |approve my payment forms |track which payment forms have been approved

|`*` |NUS Treasurer |categorise the payment forms I submitted into projects |keep track of the payment forms belonging to a particular project

|`*` |NUS Treasurer |share my payment forms |get approval from my superiors
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is `AlphaNUS` and the *Actor* is the `NUS Treasurer`, unless specified otherwise)

=== Use case: Add a new project

*MSS*

1.  User requests to add a new project.
2.  AlphaNUS adds a new project to its record.
+
Use case ends.

*Extensions*

[none]
* 1a. The user types in an invalid command.
** 1a1. AlphaNUS shows an error message.
+
Use case ends.

* 2a. There is no current project being worked on.
** 2a1. AlphaNUS adds a new project to its record.
** 2a2. AlphaNUS updates the current project to the newly created project.
+
Use case ends.

=== Use case: Delete a project

*MSS*

1.  User requests to delete a project.
2.  AlphaNUS deletes the project from its record.
+
Use case ends.

*Extensions*

[none]
* 1a. The user types in an invalid command.
** 1a1. AlphaNUS shows an error message.
+
Use case ends.

* 2a. The project to delete is the current project being worked on.
** 2a1. AlphaNUS removes the project from being currently worked on.
** 2a2. AlphaNUS deletes the project from its record.
+
Use case ends.

=== Use case: Go to a project.

*MSS*

1.  User requests to go to a project.
2.  AlphaNUS sets the current project being worked on to the project specified.
+
Use case ends.

*Extensions*

[none]
* 1a. The user types in an invalid command.
** 1a1. AlphaNUS shows an error message.
+
Use case ends.

=== Use case: Add a new deadline

*MSS*

`1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “`Payments” and “Payment History”.
3.  User types in the command line the deadline description and time.
4.  AlphaNUS adds the deadline.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in an invalid deadline command.
** 3a1. AlphaNUS shows an error message and the correct deadline input format.
+
Use case ends.

=== Use case: Add a new payment form

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User types in the command line the payment description, items and the cost of each item.
4.  AlphaNUS adds the payment form.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in an invalid payment command.
** 3a1. AlphaNUS shows an error message and the correct payment input format.
+
Use case ends.

=== Use case: Delete an existing payee

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User types in the command line the payee's name.
4.  AlphaNUS deletes the payee.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in a payee that does not exist.
** 3a1. AlphaNUS shows a non-existing payee error message.
+
Use case ends.

=== Use case: Find a payment form or deadline

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User types in the command line the command to find and a keyword containing part of the description of a deadline or payment form.
4.  AlphaNUS lists the deadlines and payment forms with descriptions that matches the keyword.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in an invalid find command.
** 3a1. AlphaNUS shows an error message and the correct find input format.
+
Use case ends.

[none]
* 3b. User types in a keyword that returns no match.
** 3b1. AlphaNUS shows a no-match error message.
+
Use case ends.

=== Use case: Edit the description of a payment form or a deadline

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User types in command line the command to edit a payment form or deadline with a new description.
4.  AlphaNUS updates the payment form/deadline with the new description.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in a non-existing id.
** 3a1. AlphaNUS shows a non-existing id error message.
+
Use case ends.

=== Use case: Edit the time of a deadline

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User requests to reschedule a deadline to a new time.
4.  AlphaNUS updates the deadline with the new time.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in a non-existing id for a deadline.
** 3a1. AlphaNUS shows a non-existing id error message.
+
Use case ends.

[none]
* 3b. User types in an invalid time.
** 3b1. AlphaNUS shows an invalid time error message.
+
Use case ends.

[none]
* 3c. User requests to snooze the deadline.
** 3c1. AlphaNUS snoozes the deadline by 1 hour.
+
Use case ends.

[none]
* 3d. User requests to [.underline]#find the deadline# first.
** 3d1. AlphaNUS lists the deadlines that match the keyword searched.
+
Use case resumes from step 3.

=== Use case: Edit the <<payment-details, payment details>> of a payment form

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User requests to redetail a payment form.
4.  AlphaNUS updates the payment form with its new payment details.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in a non-existing id for a payment form.
** 3a1. AlphaNUS shows a non-existing id error message.
+
Use case ends.

[none]
* 3d. User requests to [.underline]#find the payment form# first.
** 3d1. AlphaNUS lists the payment forms that match the keyword searched.
+
Use case resumes from step 3.


=== Use case: Approve a payment form

*MSS*

1.  User opens the JAR file.
2.  AlphaNUS shows a command line along with different sections such as “Deadlines”, “Payments” and “Payment History”.
3.  User requests to approve a payment form.
4.  AlphaNUS sets the payment form to approved.
+
Use case ends.

*Extensions*

[none]
* 3a. User types in a non-existing id for a payment form.
** 3a1. AlphaNUS shows a non-existing id error message.
+
Use case ends.

[none]
* 3d. User requests to [.underline]#find the payment form# first.
** 3d1. AlphaNUS lists the payment forms that match the keyword searched.
+
Use case resumes from step 3.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to support up to 1000 payment forms and deadlines without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[payment-details]] Payment Details::
The item name and its cost in a payment form.


[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the latest `alphanus.jar` link:{repoURL}/releases[here].
.. Copy the file to the folder you want to use as the home folder.
.. Run the commmand `java -jar alphanus.jar` on your terminal in the home folder.

+
Expected: Shows welcome message of AlphaNUS!

. Shutdown and Saving of Data

.. Input the `bye` command to exit the application.
.. Re-launch the app by running the command `java -jar alphanus.jar` on your terminal in the home folder again.

+
Expected: The application starts with your previously saved data.

[NOTE]
If the application is prematurely closed or crashes without the `bye` command, all data from when the application is started will be lost.


=== Backup Data for Easier Testing

. Loading Backup Files
.. After launching the app, enter the `load` command to load backup projects into the application.

+
Expected: Backup Projects and Funds will be loaded into the application.

[NOTE]
All previously changed data will be removed after executing the `load` command.

=== Managing Projects and Funds

==== Set total Fund

. Set a total fund where the projects get their budgets from.
.. Prerequisites: The total fund has not yet been set.
.. Test case: `set fund am/10000` +

+
Expected: Total fund is set. Fund details are printed.

.. Test case: `set fund am/aaa`

+
Expected: Total fund is not set. Error message is printed requesting for correct input.

.. Other incorrect set fund commands to try: `set fund`, `set fund am/`.


==== Adding a project

. Adds a new project to the record without assigning budget.
.. Test case: `add project pr/FSC am/`

+
Expected: Project called FSC is added to record. Budget and spending are set to 0. Number of projects in the record is shown.

. Adds a new project to the record and assigns budget from total funds.
.. Prerequisites: Total Fund is set and there is sufficient funds.

.. Test case: `add project pr/Open Day am/1000`

+
Expected: Project called Open Day is added to record. Budget is set to 1000.0 and Spending is set to 0. Number of projects in the record is shown.

.. Test case: `add project pr/ am/`

+
Expected: No project is added. Error message is printed stating that the project name cannot be empty.

.. Test case: `add project pr/FSC am/`

+
Expected: No project is added. Error message is printed stating that the project already exists in the record.


==== Deleting a project

. Deleting an existing project from the record.
.. Prerequisites: There are projects in the record.
.. Test case: `delete project pr/FSC`

+
Expected: Existing Project with name FSC is deleted from the record. The updated funds is also printed.

. Deleting a non-existing project from the record.
.. Test case: `delete project pr/Lalaland`

+
Expected: No project is deleted. Error message indicating that the project does not exist is printed.


==== Add fund to total fund (TO CHANGE)

. Adds more funds to total fund.
.. Prerequisites:


==== Modify total funds to new value

. Increase total funds.
.. Prerequisites: Total funds is already set.
.. Test case: `reset fund new/15000`

+
Expected: Total funds is set to 15000. Fund details are printed.

. Decrease total funds above allocated funds.
.. Prerequisites: Total funds is already set.
.. Test case: `reset fund new/9000`

+
Expected: Total funds is decreased to 9000. Fund details are printed.

. Decrease total funds below allocated funds.
.. Prerequisites: Total funds is already set.
.. Test case: `reset fund new/1`

+
Expected: Total funds not changed. Error message is printed along with the amount of allocated funds.


==== Reduce budget for a project

. Reduce budget for a project but budget remains above total spending of the project.
.. Prerequisites: Budget is assigned to a project from total fund.
.. Test case: `reduce budget pr/Open Day am/100`

+
Expected: Allocated budget for a project is reduced by 100. Updated budget details for a project is shown along with new fund details.

. Reduce budget for a project but amount to reduce is lower than total spending of the project.
.. Prerequisites: Budget is assigned to a project from total fund.
.. Test Case: `reduce budget pr/Open Day am/10000`

+
Expected: Allocated budget is not changed. Error message is shown and budget details of project is printed.

==== List Projects

. List Projects in the record with existing projects.
.. Prerequisites: Projects exist in the record.
.. Test case: `list projects`

+
Expected: Projects in the record are listed along with their budget details. Current Project being managed is also shown at the bottom.

. List Projects in the record.
.. Prerequisites: No projects exist int eh record.
.. Test case: `list projects`

+
Expected: No projects are listed. Message requesting user to add projects is printed.


==== Go to Project

. Goes to an existing project to manage its payment and payees.
.. Prerequisites: Projects exist in the record.
.. Test case: `goto 1`

+
Expected: Current project being managed is set as the project index according to the `list projects` command.

. Go to a non-existing project.
.. Prerequisites: Projects exist in the record.
.. Test case: `goto 1000`

+
Expected: Error message stating that the project with that index does not exist is printed.

=== Managing Payments and Payees for a Project
[NOTE]
You need to use the `goto` command to manage the payments and payees in a project. Use the `list projects` command to view which project you are currently managing after `Current Project:`


==== Add Payee

. Adds a payee to a project currently being managed.
.. Prerequisites: Project exists and is gone to using the `goto` command.
.. Test case: `add payee p/John e/e013021@u.nus.edu m/A0182310A ph/91993312`

+
Expected: The payee is added to the record.

. Adds a payee to a project with an existing payee already added.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee with the same name exists in the project.
.. Test case: `add payee p/John e/e0131111@u.nus.edu m/A0182399A ph/99993312`

+
Expected: Payee is not added to the project. Error message stating that a payee with the same name is printed.

==== Delete Payee

. Deletes a payee from a project.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payees exists.
.. Test case: `delete payee p/John`

+
Expected: Payee is deleted from project.

==== Add Payment

. Adds a payment made by an existing payee to a project.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee exists.
.. Test case: `add payment p/John i/food c/10 v/a01222

+
Expected: Payment is added and payment details is printed.

. Adds a payment made by a non-existing payee to a project.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee does not exist.
.. Test case: `add payment p/Karan i/food c/10 v/a01222

+
Expected: Payment is not added and error message is printed requesting payee to be added.

==== Delete Payment

. Deletes a payment made by an existing payee to a project.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee exists.
.. Test case: `add payment p/John i/food c/10 v/a01222

+
Expected: Payment is deleted and payment details is printed.

==== Find Payee

. Finds a payee in current project being managed.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee exists.
.. Test case: `find payee p/John`

+
Expected: Payee details are printed.

==== Edit Payment/Payee

. Edits payee details in the project currently being managed.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee exists.
.. Test case: `edit p/John v/a01222 f/STATUS r/APPROVED

+
Expected: Payee details are updated.

. Edits payment details of a payee in the project currently being managed.
.. Prerequisites: Project exists and is gone to using the `goto` command. Payee and payment exist.
.. Test case: `edit p/John v/ f/PHONE r/99192232`

+
Expected: Payment details are updated.

=== Task Tracking

==== Deadline

==== Set task as done

==== Delete Task

==== Find Task

==== List Tasks

==== Snooze Deadline

==== Postpone Deadline

==== Reschedule Deadline

==== View Schedule
